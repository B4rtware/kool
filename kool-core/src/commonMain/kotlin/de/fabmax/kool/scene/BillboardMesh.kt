package de.fabmax.kool.scene

import de.fabmax.kool.KoolContext
import de.fabmax.kool.math.Vec2f
import de.fabmax.kool.math.Vec3f
import de.fabmax.kool.math.toRad
import de.fabmax.kool.pipeline.Attribute
import de.fabmax.kool.pipeline.GlslType
import de.fabmax.kool.util.Color
import de.fabmax.kool.util.IndexedVertexList
import de.fabmax.kool.util.logW

/**
 * BillboardMesh draws Quads which always face to the camera. Can be used for particle systems etc. If supported
 * quads are computed by geometry shaders.
 *
 * @author fabmax
 */
open class BillboardMesh(name: String? = null) : Mesh(IndexedVertexList(Attribute.POSITIONS, Attribute.COLORS,
        Attribute.TEXTURE_COORDS, ATTR_EXTENTS, ATTR_TEX_EXTENTS, ATTR_ROTATION), name) {

    var drawOrder = DrawOrder.AS_IS

    private val indexList = mutableListOf<Int>()
    private val billboardIt = BillboardInstance()

    private var isWithGeometryShader = true

    init {
        // mesh data uses points, billboard quads are generated by geometry shader
//        meshData.primitiveType = GL_POINTS
//        shader = billboardShader {
//            colorModel = ColorModel.VERTEX_COLOR
//            lightModel = LightModel.NO_LIGHTING
//            isVertexColor = true
//            isTextureColor = true
//            isDiscardTranslucent = true
//            isReceivingShadows = false
//        }
        isCastingShadow = false
    }

    fun addQuad(center: Vec3f, size: Vec2f, rotation: Float = 0f, texCenter: Vec2f = TEX_CENTER, texSize: Vec2f = TEX_SIZE_FULL, color: Color = Color.WHITE) {
        val idx = appendQuad()
        updateQuad(idx, center, size, rotation, texCenter, texSize, color)
        addQuadIndex(idx)

        if (drawOrder != DrawOrder.AS_IS) {
            indexList.add(idx)
        }
    }

    fun updateQuad(index: Int, center: Vec3f, size: Vec2f, rotation: Float = 0f, texCenter: Vec2f = TEX_CENTER, texSize: Vec2f = TEX_SIZE_FULL, color: Color = Color.WHITE) {
        if (isWithGeometryShader) {
            billboardIt.vertex.index = index
            billboardIt.vertex.position.set(center)
            billboardIt.vertex.texCoord.set(texCenter)
            billboardIt.vertex.color.set(color)
            billboardIt.extents.set(size.x * 0.5f, size.y * 0.5f)
            billboardIt.texExtents.set(texSize.x * 0.5f, texSize.y * 0.5f)
            billboardIt.rotation.f = rotation.toRad()
        } else {
            for (i in 0..3) {
                billboardIt.vertex.index = index * 4 + i
                billboardIt.vertex.position.set(center)
                billboardIt.vertex.texCoord.set(texCenter)
                billboardIt.vertex.color.set(color)
                billboardIt.extents.set(size.x * 0.5f, size.y * 0.5f).mul(SZ_EXT_SIGNS[i])
                billboardIt.texExtents.set(texSize.x * 0.5f, texSize.y * 0.5f).mul(TEX_EXT_SIGNS[i])
                billboardIt.rotation.f = rotation.toRad()
            }
        }
        geometry.isSyncRequired = true
    }

    fun clearIndices() {
        geometry.indices.clear()
    }

    fun addQuadIndex(quadIdx: Int) {
        if (isWithGeometryShader) {
            geometry.addIndex(quadIdx)
        } else {
            val idx = quadIdx * 4
            geometry.addIndex(idx)
            geometry.addIndex(idx+1)
            geometry.addIndex(idx+2)
            geometry.addIndex(idx+3)
            geometry.addIndex(idx+2)
            geometry.addIndex(idx+1)
        }
    }

    private fun appendQuad(): Int {
        return if (isWithGeometryShader) {
            // add single point vertex
            geometry.addVertex {  }
        } else {
            // add four quad vertices
            geometry.addVertex {  }
            geometry.addVertex {  }
            geometry.addVertex {  }
            geometry.addVertex {  } / 4
        }
    }

    override fun preRender(ctx: KoolContext) {
        if (isWithGeometryShader && !ctx.glCapabilities.geometryShader) {
            isWithGeometryShader = false
            logW { "Falling back to non-geometry-shader billboard mesh" }
            convertToQuadMesh()
        }

        if (drawOrder != DrawOrder.AS_IS) {
            sortElems()
        }
        super.preRender(ctx)
    }

    /**
     * Converts the point mesh to a quad mesh, in case geometry shaders are not supported.
     */
    private fun convertToQuadMesh() {
        val tmpData = IndexedVertexList(geometry.vertexAttributes)
        geometry.forEach { ptVertex ->
            for (i in 0..3) {
                tmpData.addVertex {
                    set(ptVertex)
                    getVec2fAttribute(ATTR_EXTENTS)?.mul(SZ_EXT_SIGNS[i])
                    getVec2fAttribute(ATTR_TEX_EXTENTS)?.mul(TEX_EXT_SIGNS[i])
                }
            }
        }

        for (i in 0 until geometry.numIndices) {
            val idx = geometry.indices[i] * 4
            tmpData.addIndex(idx)
            tmpData.addIndex(idx+1)
            tmpData.addIndex(idx+2)
            tmpData.addIndex(idx+3)
            tmpData.addIndex(idx+2)
            tmpData.addIndex(idx+1)
        }

        geometry.clear()
        geometry.addGeometry(tmpData)
    }

    private fun sortElems() {
        val camPos = scene?.camera?.globalPos ?: return
        val vertCnt = if (isWithGeometryShader) { 1 } else { 4 }

        if (indexList.size != geometry.numVertices / vertCnt) {
            indexList.clear()
            indexList.addAll(0 until geometry.numVertices / vertCnt)
        }

        val s = if (drawOrder == DrawOrder.FAR_FIRST) -1 else 1
        val v = geometry.vertexIt
        indexList.sortBy { idx ->
            v.index = idx * vertCnt
            v.position.sqrDistance(camPos) * s
        }

        geometry.indices.clear()
        for (i in indexList.indices) {
            addQuadIndex(indexList[i])
        }
        geometry.isSyncRequired = true
    }

    private inner class BillboardInstance {
        val vertex = geometry[0]
        val rotation = vertex.getFloatAttribute(ATTR_ROTATION)!!
        val extents =  vertex.getVec2fAttribute(ATTR_EXTENTS)!!
        val texExtents =  vertex.getVec2fAttribute(ATTR_TEX_EXTENTS)!!
    }

    enum class DrawOrder {
        AS_IS,
        FAR_FIRST,
        NEAR_FIRST
    }

    companion object {
        val ATTR_EXTENTS = Attribute("aExtents", GlslType.VEC_2F)
        val ATTR_TEX_EXTENTS = Attribute("aTexExtents", GlslType.VEC_2F)
        val ATTR_ROTATION = Attribute("aRotation", GlslType.FLOAT)

        val TEX_SIZE_FULL = Vec2f(1f, 1f)
        val TEX_CENTER = Vec2f(0.5f, 0.5f)

        private val SZ_EXT_SIGNS = listOf(Vec2f(-1f, -1f), Vec2f(1f, -1f), Vec2f(-1f, 1f), Vec2f(1f, 1f))
        private val TEX_EXT_SIGNS = listOf(Vec2f(-1f, 1f), Vec2f(1f, 1f), Vec2f(-1f, -1f), Vec2f(1f, -1f))
    }
}

package de.fabmax.kool.util

import de.fabmax.kool.KoolContext
import de.fabmax.kool.gl.GL_POINTS
import de.fabmax.kool.gl.GL_TRIANGLES
import de.fabmax.kool.math.Vec2f
import de.fabmax.kool.math.Vec3f
import de.fabmax.kool.math.toRad
import de.fabmax.kool.scene.Mesh
import de.fabmax.kool.scene.MeshData
import de.fabmax.kool.scene.Node
import de.fabmax.kool.shading.*

/**
 * BillboardMesh draws Quads which always face to the camera. Can be used for particle systems etc. If supported
 * quads are computed by geometry shaders.
 *
 * @author fabmax
 */
open class BillboardMesh(name: String? = null) : Mesh(MeshData(Attribute.POSITIONS, Attribute.COLORS,
        Attribute.TEXTURE_COORDS, ATTR_EXTENTS, ATTR_TEX_EXTENTS, ATTR_ROTATION), name) {

    var drawOrder = DrawOrder.AS_IS

    private val indexList = mutableListOf<Int>()
    private val billboardIt = BillboardInstance()

    private var isWithGeometryShader = true

    init {
        // mesh data uses points, billboard quads are generated by geometry shader
        meshData.primitiveType = GL_POINTS
        shader = billboardShader {
            colorModel = ColorModel.VERTEX_COLOR
            lightModel = LightModel.NO_LIGHTING
            isVertexColor = true
            isTextureColor = true
            isDiscardTranslucent = true
            isReceivingShadows = false
        }
        isCastingShadow = false
    }

    fun addQuad(center: Vec3f, size: Vec2f, rotation: Float = 0f, texCenter: Vec2f = TEX_CENTER, texSize: Vec2f = TEX_SIZE_FULL, color: Color = Color.WHITE) {
        val idx = appendQuad()
        updateQuad(idx, center, size, rotation, texCenter, texSize, color)
        addQuadIndex(idx)

        if (drawOrder != DrawOrder.AS_IS) {
            indexList.add(idx)
        }
    }

    fun updateQuad(index: Int, center: Vec3f, size: Vec2f, rotation: Float = 0f, texCenter: Vec2f = TEX_CENTER, texSize: Vec2f = TEX_SIZE_FULL, color: Color = Color.WHITE) {
        if (isWithGeometryShader) {
            billboardIt.vertex.index = index
            billboardIt.vertex.position.set(center)
            billboardIt.vertex.texCoord.set(texCenter)
            billboardIt.vertex.color.set(color)
            billboardIt.extents.set(size.x * 0.5f, size.y * 0.5f)
            billboardIt.texExtents.set(texSize.x * 0.5f, texSize.y * 0.5f)
            billboardIt.rotation.f = rotation.toRad()
        } else {
            for (i in 0..3) {
                billboardIt.vertex.index = index * 4 + i
                billboardIt.vertex.position.set(center)
                billboardIt.vertex.texCoord.set(texCenter)
                billboardIt.vertex.color.set(color)
                billboardIt.extents.set(size.x * 0.5f, size.y * 0.5f).mul(SZ_EXT_SIGNS[i])
                billboardIt.texExtents.set(texSize.x * 0.5f, texSize.y * 0.5f).mul(TEX_EXT_SIGNS[i])
                billboardIt.rotation.f = rotation.toRad()
            }
        }
        meshData.isSyncRequired = true
    }

    fun clearIndices() {
        meshData.vertexList.indices.clear()
    }

    fun addQuadIndex(quadIdx: Int) {
        if (isWithGeometryShader) {
            meshData.vertexList.addIndex(quadIdx)
        } else {
            val idx = quadIdx * 4
            meshData.vertexList.addIndex(idx)
            meshData.vertexList.addIndex(idx+1)
            meshData.vertexList.addIndex(idx+2)
            meshData.vertexList.addIndex(idx+3)
            meshData.vertexList.addIndex(idx+2)
            meshData.vertexList.addIndex(idx+1)
        }
    }

    private fun appendQuad(): Int {
        return if (isWithGeometryShader) {
            // add single point vertex
            meshData.addVertex {  }
        } else {
            // add four quad vertices
            meshData.addVertex {  }
            meshData.addVertex {  }
            meshData.addVertex {  }
            meshData.addVertex {  } / 4
        }
    }

    override fun preRender(ctx: KoolContext) {
        if (isWithGeometryShader && !ctx.glCapabilities.geometryShader) {
            isWithGeometryShader = false
            logW { "Falling back to non-geometry-shader billboard mesh" }
            convertToQuadMesh()
        }

        if (drawOrder != DrawOrder.AS_IS) {
            sortElems()
        }
        super.preRender(ctx)
    }

    /**
     * Converts the point mesh to a quad mesh, in case geometry shaders are not supported.
     */
    private fun convertToQuadMesh() {
        val tmpData = MeshData(meshData.vertexAttributes)
        meshData.vertexList.forEach { ptVertex ->
            for (i in 0..3) {
                tmpData.addVertex {
                    set(ptVertex)
                    getVec2fAttribute(ATTR_EXTENTS)?.mul(SZ_EXT_SIGNS[i])
                    getVec2fAttribute(ATTR_TEX_EXTENTS)?.mul(TEX_EXT_SIGNS[i])
                }
            }
        }

        for (i in 0 until meshData.numIndices) {
            val idx = meshData.vertexList.indices[i] * 4
            tmpData.addIndex(idx)
            tmpData.addIndex(idx+1)
            tmpData.addIndex(idx+2)
            tmpData.addIndex(idx+3)
            tmpData.addIndex(idx+2)
            tmpData.addIndex(idx+1)
        }

        meshData.vertexList.clear()
        meshData.vertexList.addFrom(tmpData.vertexList)
        meshData.primitiveType = GL_TRIANGLES
    }

    private fun sortElems() {
        val camPos = scene?.camera?.globalPos ?: return
        val vertCnt = if (isWithGeometryShader) { 1 } else { 4 }

        if (indexList.size != meshData.numVertices / vertCnt) {
            indexList.clear()
            indexList.addAll(0 until meshData.numVertices / vertCnt)
        }

        val s = if (drawOrder == DrawOrder.FAR_FIRST) -1 else 1
        val v = meshData.vertexList.vertexIt
        indexList.sortBy { idx ->
            v.index = idx * vertCnt
            v.position.sqrDistance(camPos) * s
        }

        meshData.vertexList.indices.clear()
        for (i in indexList.indices) {
            addQuadIndex(indexList[i])
        }
        meshData.isSyncRequired = true
    }

    private inner class BillboardInstance {
        val vertex = meshData.vertexList[0]
        val rotation = vertex.getFloatAttribute(ATTR_ROTATION)!!
        val extents =  vertex.getVec2fAttribute(ATTR_EXTENTS)!!
        val texExtents =  vertex.getVec2fAttribute(ATTR_TEX_EXTENTS)!!
    }

    enum class DrawOrder {
        AS_IS,
        FAR_FIRST,
        NEAR_FIRST
    }

    companion object {
        val ATTR_EXTENTS = Attribute("aExtents", AttributeType.VEC_2F)
        val ATTR_TEX_EXTENTS = Attribute("aTexExtents", AttributeType.VEC_2F)
        val ATTR_ROTATION = Attribute("aRotation", AttributeType.FLOAT)

        val TEX_SIZE_FULL = Vec2f(1f, 1f)
        val TEX_CENTER = Vec2f(0.5f, 0.5f)

        private val SZ_EXT_SIGNS = listOf(Vec2f(-1f, -1f), Vec2f(1f, -1f), Vec2f(-1f, 1f), Vec2f(1f, 1f))
        private val TEX_EXT_SIGNS = listOf(Vec2f(-1f, 1f), Vec2f(1f, 1f), Vec2f(-1f, -1f), Vec2f(1f, -1f))
    }
}

fun billboardShader(propsInit: ShaderProps.() -> Unit = { }): BillboardShader {
    val props = ShaderProps()
    props.propsInit()
    return BillboardShader(props, GlslGenerator())
}

class BillboardShader internal constructor(props: ShaderProps, generator: GlslGenerator) : BasicShader(props, generator) {
    init {
        generator.customAttributes += BillboardMesh.ATTR_EXTENTS
        generator.customAttributes += BillboardMesh.ATTR_TEX_EXTENTS
        generator.customAttributes += BillboardMesh.ATTR_ROTATION

        generator.injectors += object: GlslGenerator.GlslInjector {
            override fun vsAfterInput(shaderProps: ShaderProps, node: Node, text: StringBuilder, ctx: KoolContext) {
                if (ctx.glCapabilities.geometryShader) {
                    vsAfterInputGeom(text)
                } else {
                    vsAfterInputQuad(text)
                }
            }

            override fun vsEnd(shaderProps: ShaderProps, node: Node, text: StringBuilder, ctx: KoolContext) {
                if (ctx.glCapabilities.geometryShader) {
                    vsEndGeom(text)
                } else {
                    vsEndQuad(text)
                }
            }

            override fun geomShader(shaderProps: ShaderProps, node: Node, text: StringBuilder, ctx: KoolContext) {
                if (ctx.glCapabilities.geometryShader) {
                    geomShaderGeom(text)
                }
            }

            override fun fsAfterSampling(shaderProps: ShaderProps, node: Node, text: StringBuilder, ctx: KoolContext) {
                text.append("${generator.fsOutBody} = ${GlslGenerator.L_FS_TEX_COLOR} * vec4(${GlslGenerator.L_FS_VERTEX_COLOR}.rgb, 1.0) * (${GlslGenerator.L_FS_TEX_COLOR}.a * ${GlslGenerator.L_FS_VERTEX_COLOR}.a);")
            }
        }
    }

    private fun vsAfterInputGeom(text: StringBuilder) {
        // forward size extents to geometry shader
        text.append("out vec2 vsSzExtents;\n")
        text.append("out vec4 vsVertColor;\n")
        text.append("out float vsRotation;\n")
        text.append("out vec2 vsTexExtents;\nout vec2 vsCenterUv;\n")
    }

    private fun vsEndGeom(text: StringBuilder) {
        // transform position to camera space
        text.append("gl_Position = ${GlslGenerator.U_VIEW_MATRIX} * (${GlslGenerator.U_MODEL_MATRIX} * vec4(${Attribute.POSITIONS}, 1.0));")
        text.append("vsSzExtents = ${BillboardMesh.ATTR_EXTENTS};")
        text.append("vsTexExtents = ${BillboardMesh.ATTR_TEX_EXTENTS};")
        text.append("vsVertColor = ${Attribute.COLORS};\n")
        text.append("vsCenterUv = ${Attribute.TEXTURE_COORDS};\n")
        text.append("vsRotation = ${BillboardMesh.ATTR_ROTATION};\n")
    }

    private fun geomShaderGeom(text: StringBuilder) {
        text.append("""
            layout (points) in;
            layout (triangle_strip, max_vertices = 4) out;

            in vec2 vsSzExtents[];
            in vec2 vsTexExtents[];
            in float vsRotation[];

            in vec4 vsVertColor[];
            out vec4 ${GlslGenerator.V_COLOR};

            in vec2 vsCenterUv[];
            out vec2 ${GlslGenerator.V_TEX_COORD};

            uniform mat4 ${GlslGenerator.U_PROJ_MATRIX};

            void main() {
                vFragmentColor = vsVertColor[0];

                vec4 center = gl_in[0].gl_Position;
                float rot = vsRotation[0];
                vec2 ext = vsSzExtents[0];
                vec4 rt = vec4(ext.x * cos(rot), ext.x * sin(rot), 0.0, 0.0);
                vec4 up = vec4(ext.y * -sin(rot), ext.y * cos(rot), 0.0, 0.0);

                gl_Position = ${GlslGenerator.U_PROJ_MATRIX} * (center - rt - up);
                ${GlslGenerator.V_TEX_COORD} = vsCenterUv[0] + vec2(-vsTexExtents[0].x, vsTexExtents[0].y);
                EmitVertex();
                gl_Position = ${GlslGenerator.U_PROJ_MATRIX} * (center + rt - up);
                ${GlslGenerator.V_TEX_COORD} = vsCenterUv[0] + vec2(vsTexExtents[0].x, vsTexExtents[0].y);
                EmitVertex();
                gl_Position = ${GlslGenerator.U_PROJ_MATRIX} * (center - rt + up);
                ${GlslGenerator.V_TEX_COORD} = vsCenterUv[0] + vec2(-vsTexExtents[0].x, -vsTexExtents[0].y);
                EmitVertex();
                gl_Position = ${GlslGenerator.U_PROJ_MATRIX} * (center + rt + up);
                ${GlslGenerator.V_TEX_COORD} = vsCenterUv[0] + vec2(vsTexExtents[0].x, -vsTexExtents[0].y);
                EmitVertex();
                EndPrimitive();
            }
        """.trimIndent())
    }

    private fun vsAfterInputQuad(text: StringBuilder) {
        text.append("uniform mat4 ${GlslGenerator.U_PROJ_MATRIX};\n")
    }

    private fun vsEndQuad(text: StringBuilder) {
        text.append("""
            float rot = ${BillboardMesh.ATTR_ROTATION};
            vec2 ext = ${BillboardMesh.ATTR_EXTENTS};
            vec4 rt = vec4(ext.x * cos(rot), ext.x * sin(rot), 0.0, 0.0);
            vec4 up = vec4(ext.y * -sin(rot), ext.y * cos(rot), 0.0, 0.0);
            vec4 center = ${GlslGenerator.U_VIEW_MATRIX} * (${GlslGenerator.U_MODEL_MATRIX} * vec4(${Attribute.POSITIONS}, 1.0));
            gl_Position = ${GlslGenerator.U_PROJ_MATRIX} * (center + rt + up);
            ${GlslGenerator.V_TEX_COORD} += ${BillboardMesh.ATTR_TEX_EXTENTS};
        """.trimIndent()).append('\n')
    }
}
